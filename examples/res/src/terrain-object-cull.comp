#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) buffer DrawCommandBuffer {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
} drawCommandBuffer;

// contains all instances to be rendered BEFORE culling and their ids
layout(std430, set = 0, binding = 1) readonly buffer ObjectInstanceBuffer {
    uint instanceIds[];
} objectInstanceBuffer;

struct DrawObject {
    uvec4 materialId;
};

// contains all objects for the frame
layout(std430, set = 0, binding = 2) readonly buffer DrawObjectBuffer {
    DrawObject objects[];
} drawObjectBuffer;

// contains all instances to be rendered AFTER culling and their ids
layout(std430, set = 0, binding = 3) buffer DrawInstanceBuffer {
    uint instanceIds[];
} drawInstanceBuffer;

layout(push_constant) uniform PushConstants {
    mat4 view;
    vec4 frustum;
    uvec2 chunkDimensions;
    uvec2 chunkCount;
    uint totalInstances;
} pcs;

bool isVisible(uint objectId)
{
    DrawObject obj = drawObjectBuffer.objects[objectId];

    vec4 sphereBounds;// = asdasd; // ned to calc based on chunkId/instanceId, should be in world pos of the chunk

    vec3 center = (pcs.view * vec4(sphereBounds.xyz, 1.0)).xyz;
    float radius = sphereBounds.w;

    // update to full frustum cull
    // cull between left/right frustum planes
    bool visible = center.z * pcs.frustum[1] - abs(center.x) * pcs.frustum[0] > -radius;
    visible = visible && center.z * pcs.frustum[3] - abs(center.y) * pcs.frustum[2] > -radius;

    return visible;
}

void main() {
    uint gId = gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;

    if (gId >= pcs.totalInstances)
        return;

    uint chunkId = objectInstanceBuffer.instanceIds[gId];

    if (!isVisible(chunkId))
        return;

    uint relativeId = atomicAdd(drawCommandBuffer.instanceCount, 1);
    uint instanceIdx = drawCommandBuffer.firstInstance + relativeId;

    drawInstanceBuffer.instanceIds[instanceIdx] = chunkId;
}
